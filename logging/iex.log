[2011-10-31 14:29:26 CET/Data/INFO] Starting data engine
[2011-10-31 14:29:26 CET/Data/DEBUG] Data engine successfully started
[2011-10-31 14:29:26 CET/Reporting/INFO] Starting reporting engine
[2011-10-31 14:29:27 CET/ContractEngine/INFO] Starting contract engine
[2011-10-31 14:29:27 CET/ContractEngine/DEBUG] Reading prelude definitions from "defs/contracts/Prelude.csl"
[2011-10-31 14:29:27 CET/ContractEngine/DEBUG] Contract engine successfully started
[2011-10-31 14:29:27 CET/RuleEngine/INFO] Starting rule engine
[2011-10-31 14:29:27 CET/RuleEngine/DEBUG] Reading rule sets from "/home/ronni/repos/iex-bsc/rules/"
[2011-10-31 14:29:27 CET/RuleEngine/DEBUG] Reading rule sets succeeded (0 rule sets parsed)
[2011-10-31 14:29:27 CET/RuleEngine/DEBUG] Rule engine successfully started
[2011-10-31 14:29:27 CET/EventLog/INFO] Starting event log
[2011-10-31 14:29:27 CET/EventLog/DEBUG] Bootstrapping system from "/home/ronni/repos/iex-bsc/events/events.log"
[2011-10-31 14:29:27 CET/EventLog/INFO] Event log successfully started
[2011-10-31 14:29:27 CET/PServer/INFO] Starting Server on port 7911
[2011-10-31 14:29:31 CET/PServer/DEBUG] addDataDefinitions: ResourceType is Data.
ResourceType is abstract.

Currency is a ResourceType.
Currency is abstract.

DKK is a Currency.

ItemType is a ResourceType.
ItemType is abstract.

Product is an ItemType.
Product has a String called sku.
Product has a String called name.
Product has a String called description.

Agent is a Data.

Me is an Agent.

Customer is a Agent.
Customer has a String called name.
Customer has a list of Address called addresses.

Vendor is a Agent.

Address is Data.
Address has a String.
Address has a Country.

Resource is Data.
Resource is abstract.

Money is a Resource.
Money has a Currency.
Money has a Double called amount.

Item is a Resource.
Item has an ItemType.
Item has a Double called quantity.

Country is Data.
Country is abstract.

Denmark is Country.

OrderLine is Data.
OrderLine has an Item.
OrderLine has Money called unitPrice.
OrderLine has a Double called vatPercentage.

CustomerStatistics is Data.
CustomerStatistics has a Customer entity.
BiTransaction is a Transaction.
BiTransaction is abstract.
BiTransaction has an Agent entity called sender.
BiTransaction has an Agent entity called receiver.

Transfer is a BiTransaction.
Transfer is abstract.

Payment is a Transfer.
Payment is abstract.
Payment has Money.

CashPayment is a Payment.
CreditCardPayment is a Payment.
BankTransfer is a Payment.

Delivery is a Transfer.
Delivery has a list of Item called items.

IssueInvoice is a BiTransaction.
IssueInvoice has a list of OrderLine called orderLines.

RequestRepair is a BiTransaction.
RequestRepair has a list of Item called items.

Repair is a BiTransaction.
Repair has a list of Item called items.
Purchase is a Contract.
Purchase has a Vendor entity.
Purchase has a list of OrderLine called orderLines.

Sale is a Contract.
Sale has a Customer entity.
Sale has a list of OrderLine called orderLines.
Inventory is a Report.
Inventory has a list of Item called availableItems.

Customers is a Report.
Customers has a list of CustomerStatistics.

Items is a Report.
Items has a list of Item.

[2011-10-31 14:29:31 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:29:31 CET/PServer/DEBUG] createEntity: Me, Me
[2011-10-31 14:29:31 CET/PServer/DEBUG] addReport: name: Me
description:
  Returns the pseudo entity 'Me' that represents the company.
tags: internal, entity
-- Check if an agent is the company itself
isMe : <Agent> -> Bool
isMe a = a :? <Me>

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -> [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -> m.amount) m.2)} |
  m <- groupProj (\m -> m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -> [Money] -> [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -> [Money] -> [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -> m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -> [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -> is.quantity) i.2)} |
  i <- groupProj (\is -> is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr <- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -> not (isMe (inv.2).sender) && isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -> isMe inv.2.sender && not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) => a -> [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line <- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr <- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) && isMe del.receiver,
  is <- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv <- invoicesSent, line <- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv <- invoicesReceived,
  tr <- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item <- deliv.items,
  line <- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, 'take' as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity <= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv <- invoicesReceived,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv <- invoicesSent,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : <Me>
report = head [me | me : <Me> <- map (\e -> e.1) entities]

[2011-10-31 14:29:35 CET/PServer/DEBUG] addReport: name: GetEntity
description:
  Dereference an entity to get the latest version.
tags: internal, entity
-- Check if an agent is the company itself
isMe : <Agent> -> Bool
isMe a = a :? <Me>

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -> [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -> m.amount) m.2)} |
  m <- groupProj (\m -> m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -> [Money] -> [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -> [Money] -> [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -> m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -> [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -> is.quantity) i.2)} |
  i <- groupProj (\is -> is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr <- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -> not (isMe (inv.2).sender) && isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -> isMe inv.2.sender && not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) => a -> [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line <- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr <- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) && isMe del.receiver,
  is <- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv <- invoicesSent, line <- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv <- invoicesReceived,
  tr <- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item <- deliv.items,
  line <- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, 'take' as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity <= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv <- invoicesReceived,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv <- invoicesSent,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : <Data> -> Data
report ref = ref !

[2011-10-31 14:29:36 CET/PServer/DEBUG] addReport: name: ReportNamesByTags
description:
  A list of reports that have the all tags provided as first argument to the
  function and none of the tags provided as second argument.
tags: internal, report
-- Check if an agent is the company itself
isMe : <Agent> -> Bool
isMe a = a :? <Me>

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -> [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -> m.amount) m.2)} |
  m <- groupProj (\m -> m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -> [Money] -> [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -> [Money] -> [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -> m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -> [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -> is.quantity) i.2)} |
  i <- groupProj (\is -> is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr <- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -> not (isMe (inv.2).sender) && isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -> isMe inv.2.sender && not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) => a -> [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line <- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr <- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) && isMe del.receiver,
  is <- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv <- invoicesSent, line <- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv <- invoicesReceived,
  tr <- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item <- deliv.items,
  line <- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, 'take' as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity <= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv <- invoicesReceived,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv <- invoicesSent,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

filt allOf noneOf rep =
  all (\x -> elem x rep.tags) allOf &&
  not (any (\x -> elem x rep.tags) noneOf)

report : [String] -> [String] -> [String]
report allOf noneOf = [r.name | r <- filter (filt allOf noneOf) reports]

[2011-10-31 14:29:37 CET/PServer/DEBUG] addReport: name: ContractTemplates
description:
  A list of 'PutContractDef' events for each non-deleted contract template.
tags: internal, contract
-- Check if an agent is the company itself
isMe : <Agent> -> Bool
isMe a = a :? <Me>

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -> [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -> m.amount) m.2)} |
  m <- groupProj (\m -> m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -> [Money] -> [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -> [Money] -> [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -> m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -> [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -> is.quantity) i.2)} |
  i <- groupProj (\is -> is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr <- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -> not (isMe (inv.2).sender) && isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -> isMe inv.2.sender && not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) => a -> [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line <- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr <- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) && isMe del.receiver,
  is <- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv <- invoicesSent, line <- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv <- invoicesReceived,
  tr <- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item <- deliv.items,
  line <- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, 'take' as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity <= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv <- invoicesReceived,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv <- invoicesSent,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : [PutContractDef]
report = contractDefs

[2011-10-31 14:29:39 CET/PServer/DEBUG] addReport: name: Contracts
description:
  A list of all running (i.e. non-concluded) contracts.
tags: internal, contract
-- Check if an agent is the company itself
isMe : <Agent> -> Bool
isMe a = a :? <Me>

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -> [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -> m.amount) m.2)} |
  m <- groupProj (\m -> m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -> [Money] -> [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -> [Money] -> [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -> m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -> [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -> is.quantity) i.2)} |
  i <- groupProj (\is -> is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr <- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -> not (isMe (inv.2).sender) && isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -> isMe inv.2.sender && not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) => a -> [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line <- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr <- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) && isMe del.receiver,
  is <- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv <- invoicesSent, line <- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv <- invoicesReceived,
  tr <- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item <- deliv.items,
  line <- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, 'take' as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity <= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv <- invoicesReceived,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv <- invoicesSent,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : [PutContract]
report = contracts

[2011-10-31 14:29:40 CET/PServer/DEBUG] addReport: name: Inventory
description:
  A list of items in the inventory available for sale (regardless of whether we
  have paid for them).
tags: external, inventory
-- Check if an agent is the company itself
isMe : <Agent> -> Bool
isMe a = a :? <Me>

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -> [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -> m.amount) m.2)} |
  m <- groupProj (\m -> m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -> [Money] -> [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -> [Money] -> [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -> m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -> [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -> is.quantity) i.2)} |
  i <- groupProj (\is -> is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr <- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -> not (isMe (inv.2).sender) && isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -> isMe inv.2.sender && not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) => a -> [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line <- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr <- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) && isMe del.receiver,
  is <- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv <- invoicesSent, line <- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv <- invoicesReceived,
  tr <- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item <- deliv.items,
  line <- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, 'take' as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity <= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv <- invoicesReceived,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv <- invoicesSent,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : Inventory
report = 
  let itemsSold' = map (\i -> i{quantity = 0 - i.quantity}) itemsSold
  in
  -- The available items is the list of received items minus the list of reserved
  -- or sold items
  Inventory{availableItems = normaliseItems (itemsReceived ++ itemsSold')}
    

[2011-10-31 14:29:41 CET/PServer/DEBUG] addReport: name: Customers
description: A list of all customers in the database
tags: external
-- Check if an agent is the company itself
isMe : <Agent> -> Bool
isMe a = a :? <Me>

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -> [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -> m.amount) m.2)} |
  m <- groupProj (\m -> m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -> [Money] -> [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -> [Money] -> [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -> m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -> [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -> is.quantity) i.2)} |
  i <- groupProj (\is -> is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr <- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -> not (isMe (inv.2).sender) && isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -> isMe inv.2.sender && not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) => a -> [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line <- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr <- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) && isMe del.receiver,
  is <- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv <- invoicesSent, line <- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv <- invoicesReceived,
  tr <- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item <- deliv.items,
  line <- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, 'take' as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity <= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv <- invoicesReceived,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv <- invoicesSent,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : [<Customer>]
report = [c | c : <Customer> <- map (\e -> e.1) entities]

[2011-10-31 14:29:43 CET/PServer/DEBUG] addReport: name: Items
description:
  Creates a list of items in the store regardless of availability
tags: external
-- Check if an agent is the company itself
isMe : <Agent> -> Bool
isMe a = a :? <Me>

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -> [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -> m.amount) m.2)} |
  m <- groupProj (\m -> m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -> [Money] -> [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -> [Money] -> [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -> m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -> [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -> is.quantity) i.2)} |
  i <- groupProj (\is -> is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr <- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -> not (isMe (inv.2).sender) && isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -> isMe inv.2.sender && not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) => a -> [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line <- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr <- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) && isMe del.receiver,
  is <- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv <- invoicesSent, line <- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv <- invoicesReceived,
  tr <- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item <- deliv.items,
  line <- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, 'take' as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity <= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv <- invoicesReceived,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv <- invoicesSent,
  l <- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : [<Item>]
report = [i | i : <Item> <- map(\e -> e.1) entities]

[2011-10-31 14:29:44 CET/PServer/DEBUG] createContractDefinition: name: purchase
type: Purchase
description: "Set up a purchase"
// Check if 'lines' are in stock by invoking the 'Inventory' report
fun inStock lines =
  let inv = (reports.inventory ()).availableItems
  in
  all (\l -> any (\i -> (l.item).itemType == i.itemType && (l.item).quantity <= i.quantity) inv) lines

// Check that amount 'm' equals the total amount in m's currency of a list of sales lines
fun checkAmount m orderLines =
  let a = foldr (\x acc ->
            if (x.unitPrice).currency == m.currency then
              (x.item).quantity * (100 + x.vatPercentage) * (x.unitPrice).amount + acc
            else
              acc) 0 orderLines
  in
  m.amount * 100 == a

// Remove sales lines that have the currency of 'm'
fun remainingOrderLines m = filter (\x -> (x.unitPrice).currency /= m.currency)

// A reference to the designated entity that represents the company
val me = reports.me ()

clause purchase(lines : [OrderLine])<me : <Me>, vendor : <Vendor>> =
 <vendor> Delivery(sender s, receiver r, items i)
   where s == vendor && r == me && i == map (\x -> x.item) lines
   due within 1W
 then
 when IssueInvoice(sender s, receiver r, orderLines sl)
   where s == vendor && r == me && sl == lines
   due within 1Y
 then
 payment(lines, vendor, 14D)<me>

clause payment(lines : [OrderLine], vendor : <Vendor>, deadline : Duration)<me : <Me>> =
 if null lines then
   fulfilment
 else
   <me> BankTransfer(sender s, receiver r, money m)
     where s == me && r == vendor && checkAmount m lines
     due within deadline
     remaining newDeadline
   then
   payment(remainingOrderLines m lines, vendor, newDeadline)<me>

contract = purchase(orderLines)<me, vendor>

[2011-10-31 14:29:44 CET/PServer/DEBUG] createContractDefinition: name: sale
type: Sale
description: "Set up a sale"
// Check if 'lines' are in stock by invoking the 'Inventory' report
fun inStock lines =
  let inv = (reports.inventory ()).availableItems
  in
  all (\l -> any (\i -> (l.item).itemType == i.itemType && (l.item).quantity <= i.quantity) inv) lines

// Check that amount 'm' equals the total amount in m's currency of a list of sales lines
fun checkAmount m orderLines =
  let a = foldr (\x acc ->
            if (x.unitPrice).currency == m.currency then
              (x.item).quantity * (100 + x.vatPercentage) * (x.unitPrice).amount + acc
            else
              acc) 0 orderLines
  in
  m.amount * 100 == a

// Remove sales lines that have the currency of 'm'
fun remainingOrderLines m = filter (\x -> (x.unitPrice).currency /= m.currency)

// A reference to the designated entity that represents the company
val me = reports.me ()

clause sale(lines : [OrderLine])<me : <Me>, customer : <Customer>> =
 <me> IssueInvoice(sender s, receiver r, orderLines sl)
   where s == me && r == customer && sl == lines && inStock lines
   due within 1H
 then
 payment(lines, me, 10m)<customer>
 and
 <me> Delivery(sender s, receiver r, items i)
   where s == me && r == customer && i == map (\x -> x.item) lines
   due within 1W
 then
 repair(map (\x -> x.item) lines, customer, 3M)<me>

clause payment(lines : [OrderLine], me : <Me>, deadline : Duration)<customer : <Customer>> =
 if null lines then
   fulfilment
 else
   <customer> Payment(sender s, receiver r, money m)
     where s == customer && r == me && checkAmount m lines
     due within deadline
     remaining newDeadline
   then
   payment(remainingOrderLines m lines, me, newDeadline)<customer>

clause repair(items : [Item], customer : <Customer>, deadline : Duration)<me : <Me>> =
 when RequestRepair(sender s, receiver r, items i)
   where s == customer && r == me && subset i items
   due within deadline
   remaining newDeadline
 then
 <me> Repair(sender s, receiver r, items i')
   where s == me && r == customer && i == i'
   due within 5D
   remaining newDeadline'
 then
 repair(items, customer, newDeadline <-> 5D <+> newDeadline')<me>

contract = sale(orderLines)<me, customer>

[2011-10-31 14:42:16 CET/PServer/DEBUG] queryReport: ReportNamesByTags, ["external"], ["internal"]
[2011-10-31 14:42:16 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:42:16 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 14:42:16 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:42:21 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:42:22 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:42:25 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:42:25 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:42:25 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 14:42:27 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 14:42:27 CET/PServer/DEBUG] queryReport: Customers
[2011-10-31 14:42:29 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:42:29 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:42:31 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:42:33 CET/PServer/DEBUG] queryReport: ContractTemplates
[2011-10-31 14:42:33 CET/PServer/DEBUG] getRecordDefinition: Sale
[2011-10-31 14:42:33 CET/PServer/DEBUG] getRecordDefinition: Sale
[2011-10-31 14:42:35 CET/PServer/DEBUG] getRecordDefinition: Purchase
[2011-10-31 14:42:35 CET/PServer/DEBUG] getRecordDefinition: Purchase
[2011-10-31 14:42:37 CET/PServer/DEBUG] getSubTypes: OrderLine
[2011-10-31 14:42:37 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 14:42:37 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:42:38 CET/PServer/DEBUG] getSubTypes: Money
[2011-10-31 14:42:38 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 14:42:43 CET/PServer/DEBUG] getSubTypes: Currency
[2011-10-31 14:42:43 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 14:42:43 CET/PServer/DEBUG] getRecordDefinition: Currency
[2011-10-31 14:42:43 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 14:42:46 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 14:42:49 CET/PServer/DEBUG] getSubTypes: Item
[2011-10-31 14:42:49 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:42:52 CET/PServer/DEBUG] getSubTypes: ItemType
[2011-10-31 14:42:53 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:42:53 CET/PServer/DEBUG] getRecordDefinition: ItemType
[2011-10-31 14:43:04 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:43:05 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:43:07 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 14:43:08 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:43:08 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 14:43:11 CET/PServer/DEBUG] createEntity: Vendor, Vendor
[2011-10-31 14:43:11 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 14:43:11 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 14:43:13 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:43:13 CET/PServer/DEBUG] instantiateContract: Purchase{orderLines = [OrderLine{item = Item{itemType = Product{description = "",name = "",sku = "qwerty"},quantity = 1000.0},unitPrice = Money{amount = 100.0,currency = DKK},vatPercentage = 0.0}],startDate = 2011-10-31 14:42:34 UTC,templateName = "purchase",vendor = Vendor<1>}
[2011-10-31 14:43:14 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:43:15 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:43:15 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:43:15 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 14:43:15 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 14:43:15 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 14:43:16 CET/PServer/DEBUG] getSubTypes: Delivery
[2011-10-31 14:43:16 CET/PServer/DEBUG] getRecordDefinition: Delivery
[2011-10-31 14:43:16 CET/PServer/DEBUG] getRecordDefinition: Delivery
[2011-10-31 14:43:16 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:43:16 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:43:16 CET/PServer/DEBUG] getRecordDefinition: Delivery
[2011-10-31 14:43:16 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 14:43:16 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 14:43:16 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:43:16 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:43:16 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:43:16 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:43:23 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:43:23 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:43:25 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:43:25 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:43:25 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 14:43:28 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:43:28 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:43:28 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:43:28 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 14:43:28 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 14:43:28 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 14:43:29 CET/PServer/DEBUG] getSubTypes: Delivery
[2011-10-31 14:43:29 CET/PServer/DEBUG] getRecordDefinition: Delivery
[2011-10-31 14:43:29 CET/PServer/DEBUG] getRecordDefinition: Delivery
[2011-10-31 14:43:29 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:43:29 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:43:29 CET/PServer/DEBUG] getRecordDefinition: Delivery
[2011-10-31 14:43:29 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 14:43:29 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:43:29 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:43:29 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 14:43:29 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:43:29 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:43:30 CET/PServer/DEBUG] registerTransactions: <0, 2011-10-31 14:43:29 UTC, Delivery{items = [Item{itemType = Product{description = "",name = "",sku = "qwerty"},quantity = 1000.0}],receiver = Me<0>,sender = Vendor<1>}>
[2011-10-31 14:43:42 CET/PServer/DEBUG] queryReport: ReportNamesByTags, ["external"], ["internal"]
[2011-10-31 14:43:42 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:43:42 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 14:43:42 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:43:44 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:43:44 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:43:46 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:43:46 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:43:46 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 14:43:46 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:43:46 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:43:49 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:43:49 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:44:22 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:44:22 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:44:23 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 14:44:23 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:44:23 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:44:25 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:44:25 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:44:28 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:44:28 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:44:28 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:44:29 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 14:44:31 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:44:31 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:44:31 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:44:31 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 14:44:33 CET/PServer/DEBUG] getSubTypes: IssueInvoice
[2011-10-31 14:44:33 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 14:44:33 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 14:44:33 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:44:33 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:44:33 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 14:44:33 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:44:33 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:44:33 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 14:44:33 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 14:44:33 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 14:44:33 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:44:33 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 14:44:33 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:44:34 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 14:44:36 CET/PServer/DEBUG] registerTransactions: <0, 2011-10-31 14:44:35 UTC, IssueInvoice{orderLines = [OrderLine{item = Item{itemType = Product{description = "",name = "",sku = "qwerty"},quantity = 1000.0},unitPrice = Money{amount = 100.0,currency = DKK},vatPercentage = 0.0}],receiver = Me<0>,sender = Vendor<1>}>
[2011-10-31 14:44:47 CET/PServer/DEBUG] queryReport: ReportNamesByTags, ["external"], ["internal"]
[2011-10-31 14:44:47 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:44:47 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 14:44:47 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:44:49 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:44:49 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:44:49 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 14:44:49 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:44:50 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:44:52 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:44:52 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:44:52 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:44:52 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 14:44:53 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:44:53 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:44:54 CET/PServer/DEBUG] getSubTypes: BankTransfer
[2011-10-31 14:44:55 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 14:44:55 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 14:44:55 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:44:55 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:44:55 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 14:44:55 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 14:44:55 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:44:55 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:44:55 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 14:44:55 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:44:55 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 14:44:55 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 14:44:55 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:44:55 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 14:44:57 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:44:57 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:44:58 CET/PServer/DEBUG] getSubTypes: Money
[2011-10-31 14:44:58 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 14:44:58 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:44:58 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:01 CET/PServer/DEBUG] getSubTypes: Currency
[2011-10-31 14:45:01 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 14:45:02 CET/PServer/DEBUG] getRecordDefinition: Currency
[2011-10-31 14:45:02 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 14:45:03 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 14:45:04 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:04 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:04 CET/PServer/DEBUG] registerTransactions: <0, 2011-10-31 14:45:03 UTC, BankTransfer{money = Money{amount = 100.0,currency = DKK},receiver = Vendor<1>,sender = Me<0>}>
[2011-10-31 14:45:04 CET/PServer/ERROR] Contract 0: Unexpected transaction: BankTransfer{money = Money{amount = 100.0
                          ,currency = DKK}
            ,receiver = Vendor<1>
            ,sender = Me<0>}
[2011-10-31 14:45:14 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:14 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:14 CET/PServer/DEBUG] registerTransactions: <0, 2011-10-31 14:45:13 UTC, BankTransfer{money = Money{amount = 100.0,currency = DKK},receiver = Vendor<1>,sender = Me<0>}>
[2011-10-31 14:45:14 CET/PServer/ERROR] Contract 0: Unexpected transaction: BankTransfer{money = Money{amount = 100.0
                          ,currency = DKK}
            ,receiver = Vendor<1>
            ,sender = Me<0>}
[2011-10-31 14:45:14 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:14 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:14 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:45:15 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:45:17 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:17 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:17 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 14:45:17 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 14:45:18 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:18 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:45:18 CET/PServer/DEBUG] registerTransactions: <0, 2011-10-31 14:45:17 UTC, BankTransfer{money = Money{amount = 100.0,currency = DKK},receiver = Vendor<1>,sender = Me<0>}>
[2011-10-31 14:45:18 CET/PServer/ERROR] Contract 0: Unexpected transaction: BankTransfer{money = Money{amount = 100.0
                          ,currency = DKK}
            ,receiver = Vendor<1>
            ,sender = Me<0>}
[2011-10-31 14:45:23 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 14:45:23 CET/PServer/DEBUG] queryReport: Customers
[2011-10-31 14:45:25 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:45:25 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:45:27 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:45:27 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:45:27 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 14:45:27 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:45:27 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:45:29 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:45:29 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:45:29 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:45:29 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 14:45:29 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:45:29 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:45:31 CET/PServer/DEBUG] queryReport: ContractTemplates
[2011-10-31 14:45:31 CET/PServer/DEBUG] getRecordDefinition: Sale
[2011-10-31 14:45:31 CET/PServer/DEBUG] getRecordDefinition: Sale
[2011-10-31 14:45:34 CET/PServer/DEBUG] getSubTypes: OrderLine
[2011-10-31 14:45:34 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 14:45:34 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:45:36 CET/PServer/DEBUG] getSubTypes: Money
[2011-10-31 14:45:37 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 14:45:42 CET/PServer/DEBUG] getSubTypes: Currency
[2011-10-31 14:45:42 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 14:45:42 CET/PServer/DEBUG] getRecordDefinition: Currency
[2011-10-31 14:45:42 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 14:45:43 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 14:45:44 CET/PServer/DEBUG] getSubTypes: Item
[2011-10-31 14:45:44 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:45:47 CET/PServer/DEBUG] getSubTypes: ItemType
[2011-10-31 14:45:47 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:45:47 CET/PServer/DEBUG] getRecordDefinition: ItemType
[2011-10-31 14:45:52 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:45:53 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:45:54 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 14:45:55 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:45:55 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:46:00 CET/PServer/DEBUG] getSubTypes: Address
[2011-10-31 14:46:00 CET/PServer/DEBUG] getRecordDefinition: Address
[2011-10-31 14:46:02 CET/PServer/DEBUG] getSubTypes: Country
[2011-10-31 14:46:02 CET/PServer/DEBUG] getRecordDefinition: Denmark
[2011-10-31 14:46:02 CET/PServer/DEBUG] getRecordDefinition: Country
[2011-10-31 14:46:02 CET/PServer/DEBUG] getRecordDefinition: Denmark
[2011-10-31 14:46:03 CET/PServer/DEBUG] getRecordDefinition: Address
[2011-10-31 14:46:03 CET/PServer/DEBUG] createEntity: Customer{addresses = [Address{country = Denmark,string = ""}],name = "foo"}, Customer
[2011-10-31 14:46:03 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:46:03 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:46:08 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:46:08 CET/PServer/DEBUG] instantiateContract: Sale{customer = Customer<2>,orderLines = [OrderLine{item = Item{itemType = Product{description = "",name = "",sku = "qwerty"},quantity = 10.0},unitPrice = Money{amount = 30.0,currency = DKK},vatPercentage = 0.0}],startDate = 2011-10-31 14:45:30 UTC,templateName = "sale"}
[2011-10-31 14:46:09 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:46:09 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:46:09 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:46:09 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:46:09 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 14:46:10 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 14:46:10 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:46:10 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:46:10 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:46:10 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:46:11 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:46:12 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:46:14 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 14:46:14 CET/PServer/DEBUG] queryReport: Customers
[2011-10-31 14:46:14 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:46:14 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:46:16 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:46:16 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:46:16 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 14:46:16 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:46:16 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:46:18 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:46:18 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:46:18 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:46:18 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:46:19 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 14:46:19 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 14:46:19 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:46:19 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:46:19 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:46:19 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:46:20 CET/PServer/DEBUG] getSubTypes: IssueInvoice
[2011-10-31 14:46:20 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 14:46:21 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:46:21 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:46:22 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 14:46:22 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:46:22 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:46:22 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 14:46:22 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:46:22 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:46:22 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 14:46:22 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:46:22 CET/PServer/DEBUG] registerTransactions: <1, 2011-10-31 14:46:21 UTC, IssueInvoice{orderLines = [OrderLine{item = Item{itemType = Product{description = "",name = "",sku = "qwerty"},quantity = 10.0},unitPrice = Money{amount = 30.0,currency = DKK},vatPercentage = 0.0}],receiver = Customer<2>,sender = Me<0>}>
[2011-10-31 14:46:22 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:46:22 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 14:46:22 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:46:22 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 14:46:22 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:46:28 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:46:28 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:46:28 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:46:28 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:46:28 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 14:46:28 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 14:46:29 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:46:29 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:46:29 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:46:29 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:46:29 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:46:29 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:46:40 CET/PServer/DEBUG] getSubTypes: Payment
[2011-10-31 14:46:40 CET/PServer/DEBUG] getRecordDefinition: CashPayment
[2011-10-31 14:46:40 CET/PServer/DEBUG] getRecordDefinition: CreditCardPayment
[2011-10-31 14:46:40 CET/PServer/DEBUG] getRecordDefinition: Payment
[2011-10-31 14:46:40 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 14:46:40 CET/PServer/DEBUG] getRecordDefinition: Payment
[2011-10-31 14:46:40 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:46:40 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:46:42 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 14:46:42 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 14:46:42 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:46:42 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:46:42 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:46:42 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:46:42 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:46:42 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:46:42 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:46:42 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:46:45 CET/PServer/DEBUG] getSubTypes: Money
[2011-10-31 14:46:45 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 14:46:45 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:46:45 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:46:49 CET/PServer/DEBUG] getSubTypes: Currency
[2011-10-31 14:46:49 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 14:46:49 CET/PServer/DEBUG] getRecordDefinition: Currency
[2011-10-31 14:46:49 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 14:46:50 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 14:46:52 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:46:52 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:46:52 CET/PServer/DEBUG] registerTransactions: <1, 2011-10-31 14:46:51 UTC, BankTransfer{money = Money{amount = 100.0,currency = DKK},receiver = Me<0>,sender = Customer<2>}>
[2011-10-31 14:46:52 CET/PServer/ERROR] Contract 1: Unexpected transaction: BankTransfer{money = Money{amount = 100.0
                          ,currency = DKK}
            ,receiver = Me<0>
            ,sender = Customer<2>}
[2011-10-31 14:46:56 CET/PServer/DEBUG] getSubTypes: Delivery
[2011-10-31 14:46:56 CET/PServer/DEBUG] getRecordDefinition: Delivery
[2011-10-31 14:46:56 CET/PServer/DEBUG] getRecordDefinition: Delivery
[2011-10-31 14:46:56 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:46:56 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 14:46:56 CET/PServer/DEBUG] getRecordDefinition: Delivery
[2011-10-31 14:46:56 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:46:56 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:46:56 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:46:56 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:46:57 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:46:57 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:47:00 CET/PServer/DEBUG] registerTransactions: <1, 2011-10-31 14:46:59 UTC, Delivery{items = [Item{itemType = Product{description = "",name = "",sku = "qwerty"},quantity = 10.0}],receiver = Customer<2>,sender = Me<0>}>
[2011-10-31 14:47:05 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 14:47:06 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:47:06 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 14:47:06 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 14:47:06 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 14:47:06 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 14:47:06 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:47:06 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:47:06 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 14:47:06 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 14:47:08 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:47:08 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:47:10 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 14:47:10 CET/PServer/DEBUG] queryReport: Customers
[2011-10-31 14:47:11 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:47:11 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:47:12 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:47:12 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:47:12 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 14:47:12 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:47:12 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:47:15 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 14:47:15 CET/PServer/DEBUG] queryReport: Customers
[2011-10-31 14:47:15 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:47:15 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:47:17 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:47:17 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:51:17 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:51:18 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 14:51:21 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:51:21 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:51:21 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 14:51:21 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:51:21 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:51:23 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 14:51:23 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 14:51:23 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 14:51:23 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 14:51:23 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 14:51:27 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 14:51:27 CET/PServer/DEBUG] queryReport: Customers
[2011-10-31 14:51:27 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 14:51:27 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 14:51:29 CET/PServer/DEBUG] getReport: Items
[2011-10-31 14:51:29 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 15:34:18 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 15:34:19 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:34:19 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:34:19 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 15:34:19 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 15:34:19 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 15:34:19 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:34:19 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:34:19 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:34:19 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:34:23 CET/PServer/DEBUG] getSubTypes: BankTransfer
[2011-10-31 15:34:23 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:34:23 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:34:23 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:34:23 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:34:23 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:34:23 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:34:23 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:34:23 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 15:34:23 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:34:23 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 15:34:23 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:34:23 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 15:34:23 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:34:23 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 15:34:32 CET/PServer/DEBUG] queryReport: ContractTemplates
[2011-10-31 15:34:32 CET/PServer/DEBUG] getRecordDefinition: Sale
[2011-10-31 15:34:32 CET/PServer/DEBUG] getRecordDefinition: Sale
[2011-10-31 15:34:41 CET/PServer/DEBUG] getSubTypes: OrderLine
[2011-10-31 15:34:41 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 15:34:42 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:34:43 CET/PServer/DEBUG] getSubTypes: Money
[2011-10-31 15:34:43 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 15:34:45 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 15:34:46 CET/PServer/DEBUG] getSubTypes: Item
[2011-10-31 15:34:46 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 15:34:50 CET/PServer/DEBUG] getSubTypes: ItemType
[2011-10-31 15:34:50 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 15:34:50 CET/PServer/DEBUG] getRecordDefinition: ItemType
[2011-10-31 15:34:55 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 15:34:55 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 15:34:56 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 15:34:58 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:34:58 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:35:02 CET/PServer/DEBUG] getSubTypes: Address
[2011-10-31 15:35:02 CET/PServer/DEBUG] getRecordDefinition: Address
[2011-10-31 15:35:03 CET/PServer/DEBUG] getSubTypes: Country
[2011-10-31 15:35:03 CET/PServer/DEBUG] getRecordDefinition: Denmark
[2011-10-31 15:35:03 CET/PServer/DEBUG] getRecordDefinition: Country
[2011-10-31 15:35:03 CET/PServer/DEBUG] getRecordDefinition: Denmark
[2011-10-31 15:35:04 CET/PServer/DEBUG] getRecordDefinition: Address
[2011-10-31 15:35:04 CET/PServer/DEBUG] createEntity: Customer{addresses = [Address{country = Denmark,string = ""}],name = "foo"}, Customer
[2011-10-31 15:35:04 CET/PServer/DEBUG] queryReport: GetEntity, Customer<3>
[2011-10-31 15:35:04 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:35:07 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:35:31 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:35:37 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:35:37 CET/PServer/DEBUG] queryReport: GetEntity, Customer<3>
[2011-10-31 15:35:37 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:35:37 CET/PServer/DEBUG] getRecordDefinition: Address
[2011-10-31 15:35:38 CET/PServer/DEBUG] queryReport: GetEntity, Customer<3>
[2011-10-31 15:35:41 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:35:41 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 15:35:41 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 15:35:47 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 15:35:50 CET/PServer/DEBUG] getSubTypes: Currency
[2011-10-31 15:35:50 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 15:35:50 CET/PServer/DEBUG] getRecordDefinition: Currency
[2011-10-31 15:35:50 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 15:35:54 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 15:35:54 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 15:35:55 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:35:56 CET/PServer/DEBUG] instantiateContract: Sale{customer = Customer<3>,orderLines = [OrderLine{item = Item{itemType = Product{description = "",name = "",sku = "aghast"},quantity = 15.0},unitPrice = Money{amount = 100.0,currency = DKK},vatPercentage = 0.0}],startDate = 2011-10-31 15:34:32 UTC,templateName = "sale"}
[2011-10-31 15:35:57 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 15:35:57 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:35:58 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:35:58 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:35:58 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 15:35:58 CET/PServer/DEBUG] getExpectedTransactions: 2
[2011-10-31 15:35:58 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 15:35:58 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 15:35:58 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:35:58 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:35:58 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:35:58 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:35:58 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:35:59 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:36:05 CET/PServer/DEBUG] getSubTypes: IssueInvoice
[2011-10-31 15:36:05 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 15:36:05 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:36:05 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:36:05 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:36:05 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:36:05 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:36:05 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:36:05 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:36:05 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:36:05 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:36:06 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:36:06 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:36:06 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:36:06 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 15:36:06 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:36:06 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:36:06 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 15:36:06 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:36:06 CET/PServer/DEBUG] queryReport: GetEntity, Customer<3>
[2011-10-31 15:36:06 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 15:36:06 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:36:06 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:36:06 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 15:36:07 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 15:36:07 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 15:36:07 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 15:37:11 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 15:37:11 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:37:11 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:37:11 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:37:11 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 15:37:11 CET/PServer/DEBUG] getExpectedTransactions: 2
[2011-10-31 15:37:11 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 15:37:11 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 15:37:11 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:37:11 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:37:11 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:37:11 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:37:11 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:37:11 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:38:50 CET/PServer/DEBUG] getSubTypes: IssueInvoice
[2011-10-31 15:38:50 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 15:38:50 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:38:50 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:38:50 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:38:50 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:38:50 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:38:50 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:38:50 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:38:50 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:38:51 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:38:51 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:38:51 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:38:51 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 15:38:51 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 15:38:51 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:38:51 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:38:51 CET/PServer/DEBUG] getRecordDefinition: IssueInvoice
[2011-10-31 15:38:51 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:38:51 CET/PServer/DEBUG] queryReport: GetEntity, Customer<3>
[2011-10-31 15:38:51 CET/PServer/DEBUG] getRecordDefinition: OrderLine
[2011-10-31 15:38:51 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:38:51 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:38:51 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 15:38:51 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 15:38:51 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 15:38:51 CET/PServer/DEBUG] getRecordDefinition: Product
[2011-10-31 15:40:02 CET/PServer/DEBUG] queryReport: ContractTemplates
[2011-10-31 15:40:02 CET/PServer/DEBUG] getRecordDefinition: Sale
[2011-10-31 15:40:02 CET/PServer/DEBUG] getRecordDefinition: Sale
[2011-10-31 15:41:41 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:50:33 CET/PServer/DEBUG] queryReport: ReportNamesByTags, ["external"], ["internal"]
[2011-10-31 15:50:33 CET/PServer/DEBUG] getReport: Items
[2011-10-31 15:50:33 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 15:50:33 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:50:35 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 15:50:35 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:50:35 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:50:35 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:50:35 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 15:50:35 CET/PServer/DEBUG] getExpectedTransactions: 2
[2011-10-31 15:50:35 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 15:50:35 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 15:50:35 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:50:35 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:50:35 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:50:35 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:50:36 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:50:36 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:50:39 CET/PServer/DEBUG] getSubTypes: Payment
[2011-10-31 15:50:39 CET/PServer/DEBUG] getRecordDefinition: CashPayment
[2011-10-31 15:50:39 CET/PServer/DEBUG] getRecordDefinition: CreditCardPayment
[2011-10-31 15:50:40 CET/PServer/DEBUG] getRecordDefinition: Payment
[2011-10-31 15:50:40 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:50:40 CET/PServer/DEBUG] getRecordDefinition: Payment
[2011-10-31 15:50:40 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:50:40 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:50:42 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:50:42 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:50:42 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:50:42 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:50:42 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:50:42 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:50:42 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:50:42 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:50:42 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:50:42 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:50:43 CET/PServer/DEBUG] getSubTypes: Money
[2011-10-31 15:50:43 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 15:50:43 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:50:43 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:50:47 CET/PServer/DEBUG] getSubTypes: Currency
[2011-10-31 15:50:47 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 15:50:47 CET/PServer/DEBUG] getRecordDefinition: Currency
[2011-10-31 15:50:47 CET/PServer/DEBUG] getRecordDefinition: DKK
[2011-10-31 15:50:49 CET/PServer/DEBUG] getRecordDefinition: Money
[2011-10-31 15:50:52 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:50:52 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:50:52 CET/PServer/DEBUG] registerTransactions: <1, 2011-10-31 15:50:52 UTC, BankTransfer{money = Money{amount = 1000.0,currency = DKK},receiver = Me<0>,sender = Customer<2>}>
[2011-10-31 15:50:52 CET/PServer/ERROR] Contract 1: Unexpected transaction: BankTransfer{money = Money{amount = 1000.0
                          ,currency = DKK}
            ,receiver = Me<0>
            ,sender = Customer<2>}
[2011-10-31 15:51:12 CET/PServer/DEBUG] queryReport: ReportNamesByTags, ["external"], ["internal"]
[2011-10-31 15:51:12 CET/PServer/DEBUG] getReport: Items
[2011-10-31 15:51:12 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 15:51:13 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:51:15 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 15:51:15 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:15 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:15 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:16 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 15:51:16 CET/PServer/DEBUG] getExpectedTransactions: 2
[2011-10-31 15:51:16 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 15:51:16 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 15:51:16 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:16 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:51:16 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:17 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:51:17 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:17 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:19 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 15:51:19 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:19 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:19 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:19 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 15:51:19 CET/PServer/DEBUG] getExpectedTransactions: 2
[2011-10-31 15:51:19 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 15:51:19 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 15:51:20 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:20 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:51:20 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:20 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:20 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:51:20 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:25 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 15:51:25 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:25 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:25 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:25 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 15:51:26 CET/PServer/DEBUG] getExpectedTransactions: 2
[2011-10-31 15:51:26 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 15:51:26 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 15:51:26 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:26 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:51:26 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:26 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:26 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:51:26 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:29 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 15:51:29 CET/PServer/DEBUG] queryReport: Customers
[2011-10-31 15:51:29 CET/PServer/DEBUG] queryReport: GetEntity, Customer<3>
[2011-10-31 15:51:29 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:51:29 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:51:29 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:51:33 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 15:51:33 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:33 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:33 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:33 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 15:51:33 CET/PServer/DEBUG] getExpectedTransactions: 2
[2011-10-31 15:51:33 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 15:51:33 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 15:51:33 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:34 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:51:34 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:34 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:35 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:51:35 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:38 CET/PServer/DEBUG] queryReport: ReportNamesByTags, ["external"], ["internal"]
[2011-10-31 15:51:39 CET/PServer/DEBUG] getReport: Items
[2011-10-31 15:51:39 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 15:51:39 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:51:45 CET/PServer/DEBUG] queryReport: Contracts
[2011-10-31 15:51:45 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:45 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:45 CET/PServer/DEBUG] getSubTypes: Customer
[2011-10-31 15:51:45 CET/PServer/DEBUG] getSubTypes: Vendor
[2011-10-31 15:51:45 CET/PServer/DEBUG] getExpectedTransactions: 2
[2011-10-31 15:51:46 CET/PServer/DEBUG] getExpectedTransactions: 1
[2011-10-31 15:51:46 CET/PServer/DEBUG] getExpectedTransactions: 0
[2011-10-31 15:51:46 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:46 CET/PServer/DEBUG] queryReport: GetEntity, Customer<2>
[2011-10-31 15:51:46 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:46 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:46 CET/PServer/DEBUG] getRecordDefinition: Customer
[2011-10-31 15:51:46 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:51 CET/PServer/DEBUG] getSubTypes: BankTransfer
[2011-10-31 15:51:52 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:51:52 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:51:52 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:51:52 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:51:52 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:51:52 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:51:52 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:52 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 15:51:52 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:51:52 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 15:51:52 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:52 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 15:51:52 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:51:52 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 15:52:40 CET/PServer/DEBUG] getSubTypes: BankTransfer
[2011-10-31 15:52:40 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:52:41 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:52:41 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:52:41 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:52:41 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:52:41 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:52:41 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:52:41 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 15:52:41 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:52:41 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 15:52:41 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:52:41 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 15:52:41 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:52:41 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 15:53:40 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:53:40 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:53:41 CET/PServer/DEBUG] getSubTypes: BankTransfer
[2011-10-31 15:53:41 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:53:42 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:53:42 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:53:42 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:53:42 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:53:43 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:53:43 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:53:43 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 15:53:44 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:53:44 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 15:53:44 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:53:45 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 15:53:45 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:53:45 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 15:54:18 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:54:18 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:54:18 CET/PServer/DEBUG] getSubTypes: BankTransfer
[2011-10-31 15:54:18 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:54:18 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:54:18 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:54:18 CET/PServer/DEBUG] getSubTypes: Agent
[2011-10-31 15:54:18 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:54:18 CET/PServer/DEBUG] getRecordDefinition: BankTransfer
[2011-10-31 15:54:18 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:54:18 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 15:54:18 CET/PServer/DEBUG] queryReport: GetEntity, Me<0>
[2011-10-31 15:54:18 CET/PServer/DEBUG] queryReport: GetEntity, Vendor<1>
[2011-10-31 15:54:18 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:54:18 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 15:54:18 CET/PServer/DEBUG] getRecordDefinition: Me
[2011-10-31 15:54:18 CET/PServer/DEBUG] getRecordDefinition: Vendor
[2011-10-31 15:57:17 CET/PServer/DEBUG] queryReport: ReportNamesByTags, ["external"], ["internal"]
[2011-10-31 15:57:17 CET/PServer/DEBUG] getReport: Items
[2011-10-31 15:57:17 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 15:57:17 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:57:18 CET/PServer/DEBUG] queryReport: ReportNamesByTags, ["external"], ["internal"]
[2011-10-31 15:57:18 CET/PServer/DEBUG] getReport: Items
[2011-10-31 15:57:18 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 15:57:18 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:59:00 CET/PServer/DEBUG] queryReport: ReportNamesByTags, ["external"], ["internal"]
[2011-10-31 15:59:00 CET/PServer/DEBUG] getReport: Items
[2011-10-31 15:59:00 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 15:59:00 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 15:59:58 CET/PServer/DEBUG] queryReport: ReportNamesByTags, ["external"], ["internal"]
[2011-10-31 15:59:59 CET/PServer/DEBUG] getReport: Items
[2011-10-31 15:59:59 CET/PServer/DEBUG] getReport: Customers
[2011-10-31 15:59:59 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 16:00:01 CET/PServer/DEBUG] getReport: Items
[2011-10-31 16:00:01 CET/PServer/DEBUG] queryReport: Items
[2011-10-31 16:00:11 CET/PServer/DEBUG] getReport: Inventory
[2011-10-31 16:00:11 CET/PServer/DEBUG] queryReport: Inventory
[2011-10-31 16:00:11 CET/PServer/DEBUG] getRecordDefinition: Inventory
[2011-10-31 16:00:11 CET/PServer/DEBUG] getRecordDefinition: Item
[2011-10-31 16:00:11 CET/PServer/DEBUG] getRecordDefinition: Product
