<record xmlns="http://poets.diku.dk/values" name="AddDataDefs"><field name="defs"><string value="ResourceType is Data.
ResourceType is abstract.

Currency is a ResourceType.
Currency is abstract.

DKK is a Currency.

ItemType is a ResourceType.
ItemType is abstract.

Product is an ItemType.
Product has a String called sku.
Product has a String called name.
Product has a String called description.

Agent is a Data.

Me is an Agent.

Customer is a Agent.
Customer has a String called name.
Customer has a list of Address called addresses.

Vendor is a Agent.

Address is Data.
Address has a String.
Address has a Country.

Resource is Data.
Resource is abstract.

Money is a Resource.
Money has a Currency.
Money has a Double called amount.

Item is a Resource.
Item has an ItemType.
Item has a Double called quantity.

Country is Data.
Country is abstract.

Denmark is Country.

OrderLine is Data.
OrderLine has an Item.
OrderLine has Money called unitPrice.
OrderLine has a Double called vatPercentage.

CustomerStatistics is Data.
CustomerStatistics has a Customer entity.
BiTransaction is a Transaction.
BiTransaction is abstract.
BiTransaction has an Agent entity called sender.
BiTransaction has an Agent entity called receiver.

Transfer is a BiTransaction.
Transfer is abstract.

Payment is a Transfer.
Payment is abstract.
Payment has Money.

CashPayment is a Payment.
CreditCardPayment is a Payment.
BankTransfer is a Payment.

Delivery is a Transfer.
Delivery has a list of Item called items.

IssueInvoice is a BiTransaction.
IssueInvoice has a list of OrderLine called orderLines.

RequestRepair is a BiTransaction.
RequestRepair has a list of Item called items.

Repair is a BiTransaction.
Repair has a list of Item called items.
Purchase is a Contract.
Purchase has a Vendor entity.
Purchase has a list of OrderLine called orderLines.

Sale is a Contract.
Sale has a Customer entity.
Sale has a list of OrderLine called orderLines.
Inventory is a Report.
Inventory has a list of Item called availableItems.

Customers is a Report.
Customers has a list of CustomerStatistics.

Items is a Report.
Items has a list of Item.
" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:31.903539Z" /></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateEntity"><field name="data"><record name="Me" /></field><field name="ent"><reference name="Me" refId="0" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:31.948618Z" /></field><field name="recordType"><string value="Me" /></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateReport"><field name="description"><string value="Returns the pseudo entity &#39;Me&#39; that represents the company.
" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:35.020025Z" /></field><field name="name"><string value="Me" /></field><field name="parrotCode"><string value="name: Me
description:
  Returns the pseudo entity &#39;Me&#39; that represents the company.
tags: internal, entity
-- Check if an agent is the company itself
isMe : &lt;Agent&gt; -&gt; Bool
isMe a = a :? &lt;Me&gt;

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -&gt; [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -&gt; m.amount) m.2)} |
  m &lt;- groupProj (\m -&gt; m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -&gt; [Money] -&gt; [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -&gt; [Money] -&gt; [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -&gt; m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -&gt; [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -&gt; is.quantity) i.2)} |
  i &lt;- groupProj (\is -&gt; is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr &lt;- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -&gt; not (isMe (inv.2).sender) &amp;&amp; isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -&gt; isMe inv.2.sender &amp;&amp; not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) =&gt; a -&gt; [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line &lt;- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr &lt;- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) &amp;&amp; isMe del.receiver,
  is &lt;- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv &lt;- invoicesSent, line &lt;- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv &lt;- invoicesReceived,
  tr &lt;- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item &lt;- deliv.items,
  line &lt;- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, &#39;take&#39; as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity &lt;= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv &lt;- invoicesReceived,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv &lt;- invoicesSent,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : &lt;Me&gt;
report = head [me | me : &lt;Me&gt; &lt;- map (\e -&gt; e.1) entities]
" /></field><field name="tags"><list><string value="internal" /><string value="entity" /></list></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateReport"><field name="description"><string value="Dereference an entity to get the latest version.
" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:36.342992Z" /></field><field name="name"><string value="GetEntity" /></field><field name="parrotCode"><string value="name: GetEntity
description:
  Dereference an entity to get the latest version.
tags: internal, entity
-- Check if an agent is the company itself
isMe : &lt;Agent&gt; -&gt; Bool
isMe a = a :? &lt;Me&gt;

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -&gt; [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -&gt; m.amount) m.2)} |
  m &lt;- groupProj (\m -&gt; m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -&gt; [Money] -&gt; [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -&gt; [Money] -&gt; [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -&gt; m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -&gt; [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -&gt; is.quantity) i.2)} |
  i &lt;- groupProj (\is -&gt; is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr &lt;- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -&gt; not (isMe (inv.2).sender) &amp;&amp; isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -&gt; isMe inv.2.sender &amp;&amp; not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) =&gt; a -&gt; [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line &lt;- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr &lt;- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) &amp;&amp; isMe del.receiver,
  is &lt;- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv &lt;- invoicesSent, line &lt;- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv &lt;- invoicesReceived,
  tr &lt;- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item &lt;- deliv.items,
  line &lt;- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, &#39;take&#39; as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity &lt;= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv &lt;- invoicesReceived,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv &lt;- invoicesSent,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : &lt;Data&gt; -&gt; Data
report ref = ref !
" /></field><field name="tags"><list><string value="internal" /><string value="entity" /></list></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateReport"><field name="description"><string value="A list of reports that have the all tags provided as first argument to the
function and none of the tags provided as second argument.
" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:37.733485Z" /></field><field name="name"><string value="ReportNamesByTags" /></field><field name="parrotCode"><string value="name: ReportNamesByTags
description:
  A list of reports that have the all tags provided as first argument to the
  function and none of the tags provided as second argument.
tags: internal, report
-- Check if an agent is the company itself
isMe : &lt;Agent&gt; -&gt; Bool
isMe a = a :? &lt;Me&gt;

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -&gt; [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -&gt; m.amount) m.2)} |
  m &lt;- groupProj (\m -&gt; m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -&gt; [Money] -&gt; [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -&gt; [Money] -&gt; [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -&gt; m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -&gt; [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -&gt; is.quantity) i.2)} |
  i &lt;- groupProj (\is -&gt; is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr &lt;- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -&gt; not (isMe (inv.2).sender) &amp;&amp; isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -&gt; isMe inv.2.sender &amp;&amp; not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) =&gt; a -&gt; [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line &lt;- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr &lt;- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) &amp;&amp; isMe del.receiver,
  is &lt;- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv &lt;- invoicesSent, line &lt;- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv &lt;- invoicesReceived,
  tr &lt;- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item &lt;- deliv.items,
  line &lt;- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, &#39;take&#39; as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity &lt;= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv &lt;- invoicesReceived,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv &lt;- invoicesSent,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

filt allOf noneOf rep =
  all (\x -&gt; elem x rep.tags) allOf &amp;&amp;
  not (any (\x -&gt; elem x rep.tags) noneOf)

report : [String] -&gt; [String] -&gt; [String]
report allOf noneOf = [r.name | r &lt;- filter (filt allOf noneOf) reports]
" /></field><field name="tags"><list><string value="internal" /><string value="report" /></list></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateReport"><field name="description"><string value="A list of &#39;PutContractDef&#39; events for each non-deleted contract template.
" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:39.061603Z" /></field><field name="name"><string value="ContractTemplates" /></field><field name="parrotCode"><string value="name: ContractTemplates
description:
  A list of &#39;PutContractDef&#39; events for each non-deleted contract template.
tags: internal, contract
-- Check if an agent is the company itself
isMe : &lt;Agent&gt; -&gt; Bool
isMe a = a :? &lt;Me&gt;

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -&gt; [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -&gt; m.amount) m.2)} |
  m &lt;- groupProj (\m -&gt; m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -&gt; [Money] -&gt; [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -&gt; [Money] -&gt; [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -&gt; m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -&gt; [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -&gt; is.quantity) i.2)} |
  i &lt;- groupProj (\is -&gt; is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr &lt;- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -&gt; not (isMe (inv.2).sender) &amp;&amp; isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -&gt; isMe inv.2.sender &amp;&amp; not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) =&gt; a -&gt; [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line &lt;- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr &lt;- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) &amp;&amp; isMe del.receiver,
  is &lt;- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv &lt;- invoicesSent, line &lt;- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv &lt;- invoicesReceived,
  tr &lt;- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item &lt;- deliv.items,
  line &lt;- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, &#39;take&#39; as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity &lt;= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv &lt;- invoicesReceived,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv &lt;- invoicesSent,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : [PutContractDef]
report = contractDefs
" /></field><field name="tags"><list><string value="internal" /><string value="contract" /></list></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateReport"><field name="description"><string value="A list of all running (i.e. non-concluded) contracts.
" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:40.376745Z" /></field><field name="name"><string value="Contracts" /></field><field name="parrotCode"><string value="name: Contracts
description:
  A list of all running (i.e. non-concluded) contracts.
tags: internal, contract
-- Check if an agent is the company itself
isMe : &lt;Agent&gt; -&gt; Bool
isMe a = a :? &lt;Me&gt;

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -&gt; [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -&gt; m.amount) m.2)} |
  m &lt;- groupProj (\m -&gt; m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -&gt; [Money] -&gt; [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -&gt; [Money] -&gt; [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -&gt; m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -&gt; [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -&gt; is.quantity) i.2)} |
  i &lt;- groupProj (\is -&gt; is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr &lt;- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -&gt; not (isMe (inv.2).sender) &amp;&amp; isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -&gt; isMe inv.2.sender &amp;&amp; not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) =&gt; a -&gt; [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line &lt;- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr &lt;- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) &amp;&amp; isMe del.receiver,
  is &lt;- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv &lt;- invoicesSent, line &lt;- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv &lt;- invoicesReceived,
  tr &lt;- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item &lt;- deliv.items,
  line &lt;- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, &#39;take&#39; as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity &lt;= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv &lt;- invoicesReceived,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv &lt;- invoicesSent,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : [PutContract]
report = contracts
" /></field><field name="tags"><list><string value="internal" /><string value="contract" /></list></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateReport"><field name="description"><string value="A list of items in the inventory available for sale (regardless of whether we
have paid for them).
" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:41.750548Z" /></field><field name="name"><string value="Inventory" /></field><field name="parrotCode"><string value="name: Inventory
description:
  A list of items in the inventory available for sale (regardless of whether we
  have paid for them).
tags: external, inventory
-- Check if an agent is the company itself
isMe : &lt;Agent&gt; -&gt; Bool
isMe a = a :? &lt;Me&gt;

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -&gt; [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -&gt; m.amount) m.2)} |
  m &lt;- groupProj (\m -&gt; m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -&gt; [Money] -&gt; [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -&gt; [Money] -&gt; [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -&gt; m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -&gt; [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -&gt; is.quantity) i.2)} |
  i &lt;- groupProj (\is -&gt; is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr &lt;- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -&gt; not (isMe (inv.2).sender) &amp;&amp; isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -&gt; isMe inv.2.sender &amp;&amp; not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) =&gt; a -&gt; [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line &lt;- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr &lt;- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) &amp;&amp; isMe del.receiver,
  is &lt;- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv &lt;- invoicesSent, line &lt;- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv &lt;- invoicesReceived,
  tr &lt;- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item &lt;- deliv.items,
  line &lt;- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, &#39;take&#39; as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity &lt;= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv &lt;- invoicesReceived,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv &lt;- invoicesSent,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : Inventory
report = 
  let itemsSold&#39; = map (\i -&gt; i{quantity = 0 - i.quantity}) itemsSold
  in
  -- The available items is the list of received items minus the list of reserved
  -- or sold items
  Inventory{availableItems = normaliseItems (itemsReceived ++ itemsSold&#39;)}
    
" /></field><field name="tags"><list><string value="external" /><string value="inventory" /></list></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateReport"><field name="description"><string value="A list of all customers in the database
" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:43.103739Z" /></field><field name="name"><string value="Customers" /></field><field name="parrotCode"><string value="name: Customers
description: A list of all customers in the database
tags: external
-- Check if an agent is the company itself
isMe : &lt;Agent&gt; -&gt; Bool
isMe a = a :? &lt;Me&gt;

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -&gt; [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -&gt; m.amount) m.2)} |
  m &lt;- groupProj (\m -&gt; m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -&gt; [Money] -&gt; [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -&gt; [Money] -&gt; [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -&gt; m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -&gt; [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -&gt; is.quantity) i.2)} |
  i &lt;- groupProj (\is -&gt; is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr &lt;- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -&gt; not (isMe (inv.2).sender) &amp;&amp; isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -&gt; isMe inv.2.sender &amp;&amp; not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) =&gt; a -&gt; [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line &lt;- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr &lt;- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) &amp;&amp; isMe del.receiver,
  is &lt;- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv &lt;- invoicesSent, line &lt;- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv &lt;- invoicesReceived,
  tr &lt;- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item &lt;- deliv.items,
  line &lt;- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, &#39;take&#39; as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity &lt;= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv &lt;- invoicesReceived,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv &lt;- invoicesSent,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : [&lt;Customer&gt;]
report = [c | c : &lt;Customer&gt; &lt;- map (\e -&gt; e.1) entities]
" /></field><field name="tags"><list><string value="external" /></list></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateReport"><field name="description"><string value="Creates a list of items in the store regardless of availability
" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:44.4332Z" /></field><field name="name"><string value="Items" /></field><field name="parrotCode"><string value="name: Items
description:
  Creates a list of items in the store regardless of availability
tags: external
-- Check if an agent is the company itself
isMe : &lt;Agent&gt; -&gt; Bool
isMe a = a :? &lt;Me&gt;

-- Normalise a list of money by grouping currencies together
normaliseMoney : [Money] -&gt; [Money]
normaliseMoney ms = [Money{currency = m.1, amount = sum (map (\m -&gt; m.amount) m.2)} |
  m &lt;- groupProj (\m -&gt; m.currency) ms]

-- Add one list of money from another
addMoney : [Money] -&gt; [Money] -&gt; [Money]
addMoney m1 m2 = normaliseMoney (m1 ++ m2)

-- Subtract one list of money from another
subtractMoney : [Money] -&gt; [Money] -&gt; [Money]
subtractMoney m1 m2 = addMoney m1 (map (\m -&gt; m{amount = 0 - m.amount}) m2)

-- Produce normalised list of all items given in list
normaliseItems : [Item] -&gt; [Item]
normaliseItems its = [Item{itemType = i.1, quantity = sum (map (\is -&gt; is.quantity) i.2)} |
  i &lt;- groupProj (\is -&gt; is.itemType) its]
 
-- List of all invoices and their associated contract ID
invoices : [(Int,IssueInvoice)]
invoices = [(tr.contractId,inv) |
  tr &lt;- transactionEvents,
  inv : IssueInvoice = tr.transaction]

-- List of all received invoices and their associated contract ID
invoicesReceived : [(Int,IssueInvoice)]
invoicesReceived = 
  filter (\inv -&gt; not (isMe (inv.2).sender) &amp;&amp; isMe (inv.2).receiver) invoices

-- List of all sent invoices and their associated contract ID
invoicesSent : [(Int,IssueInvoice)]
invoicesSent = filter (\inv -&gt; isMe inv.2.sender &amp;&amp; not (isMe inv.2.receiver)) invoices

-- Calculate the total price including VAT on an invoice
invoiceTotal : (a.orderLines : [OrderLine]) =&gt; a -&gt; [Money]
invoiceTotal inv = normaliseMoney [line.unitPrice{amount = price} |
  line &lt;- inv.orderLines,
  quantity = line.item.quantity,
  price = ((100 + line.vatPercentage) * line.unitPrice.amount * quantity) / 100]

-- List of all items delivered to the company
itemsReceived : [Item]
itemsReceived = normaliseItems [is |
  tr &lt;- transactionEvents,
  del : Delivery = tr.transaction,
  not(isMe del.sender) &amp;&amp; isMe del.receiver,
  is &lt;- del.items]

-- List of all items that have been sold
itemsSold : [Item]
itemsSold = normaliseItems [line.item | inv &lt;- invoicesSent, line &lt;- inv.2.orderLines]

-- Inventory acquisitions, that is a list of all received items and the unit
-- price of each item, exluding VAT.
invAcq : [(Item,Money)]
invAcq = [(item,line.unitPrice) |
  inv &lt;- invoicesReceived,
  tr &lt;- transactionEvents,
  tr.contractId == inv.1,
  deliv : Delivery = tr.transaction,
  item &lt;- deliv.items,
  line &lt;- inv.2.orderLines,
  line.item.itemType == item.itemType]

-- FIFO costing: Calculate the cost of all sold goods based on FIFO costing.
fifoCost : [Money]
fifoCost = let
   -- Check whether a set of items equals the current set of items in the
   -- inventory. If so, &#39;take&#39; as many of the inventory items as possible
   -- and add the price of these items to the totals.
   checkInventory y x = let
       invItem = y.1  -- The current item in the inventory
       invPrice = y.2 -- The price of the current item in the inventory
       oldInv = x.1 -- The part of the inventory that has been processed
       item = x.2 -- The item to find in the inventory
       total = x.3 -- The total costs so far
     in
     if item.itemType == invItem.itemType then let
         deltaInv =
           if invItem.quantity &lt;= item.quantity then
             []
           else
             [(invItem{quantity = invItem.quantity - item.quantity},invPrice)]
         remainingItem = item{quantity = max 0 (item.quantity - invItem.quantity)}
         price = invPrice{amount = invPrice.amount * (min item.quantity invItem.quantity)}
       in
       (oldInv ++ deltaInv, remainingItem, price # total)
     else
       (oldInv ++ [(invItem,invPrice)], item, total)

   -- Process a sold item
   processSoldItem soldItem x = let
       total = x.1 -- the total costs so far
       inv = x.2   -- the remaning inventory so far
       y = fold checkInventory ([],soldItem,total) inv
     in
     (y.3,y.1)
  in
  normaliseMoney ((fold processSoldItem ([],invAcq) itemsSold).1)

-- Outoing VAT
vatOutgoing : [Money]
vatOutgoing = normaliseMoney [price |
  inv &lt;- invoicesReceived,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

-- Incoming VAT
vatIncoming : [Money]
vatIncoming = normaliseMoney [price |
  inv &lt;- invoicesSent,
  l &lt;- inv.2.orderLines,
  price = l.unitPrice{amount = (l.vatPercentage * l.unitPrice.amount * l.item.quantity) / 100}]

report : [&lt;Item&gt;]
report = [i | i : &lt;Item&gt; &lt;- map(\e -&gt; e.1) entities]
" /></field><field name="tags"><list><string value="external" /></list></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateContractDef"><field name="cslCode"><string value="name: purchase
type: Purchase
description: &quot;Set up a purchase&quot;
// Check if &#39;lines&#39; are in stock by invoking the &#39;Inventory&#39; report
fun inStock lines =
  let inv = (reports.inventory ()).availableItems
  in
  all (\l -&gt; any (\i -&gt; (l.item).itemType == i.itemType &amp;&amp; (l.item).quantity &lt;= i.quantity) inv) lines

// Check that amount &#39;m&#39; equals the total amount in m&#39;s currency of a list of sales lines
fun checkAmount m orderLines =
  let a = foldr (\x acc -&gt;
            if (x.unitPrice).currency == m.currency then
              (x.item).quantity * (100 + x.vatPercentage) * (x.unitPrice).amount + acc
            else
              acc) 0 orderLines
  in
  m.amount * 100 == a

// Remove sales lines that have the currency of &#39;m&#39;
fun remainingOrderLines m = filter (\x -&gt; (x.unitPrice).currency /= m.currency)

// A reference to the designated entity that represents the company
val me = reports.me ()

clause purchase(lines : [OrderLine])&lt;me : &lt;Me&gt;, vendor : &lt;Vendor&gt;&gt; =
 &lt;vendor&gt; Delivery(sender s, receiver r, items i)
   where s == vendor &amp;&amp; r == me &amp;&amp; i == map (\x -&gt; x.item) lines
   due within 1W
 then
 when IssueInvoice(sender s, receiver r, orderLines sl)
   where s == vendor &amp;&amp; r == me &amp;&amp; sl == lines
   due within 1Y
 then
 payment(lines, vendor, 14D)&lt;me&gt;

clause payment(lines : [OrderLine], vendor : &lt;Vendor&gt;, deadline : Duration)&lt;me : &lt;Me&gt;&gt; =
 if null lines then
   fulfilment
 else
   &lt;me&gt; BankTransfer(sender s, receiver r, money m)
     where s == me &amp;&amp; r == vendor &amp;&amp; checkAmount m lines
     due within deadline
     remaining newDeadline
   then
   payment(remainingOrderLines m lines, vendor, newDeadline)&lt;me&gt;

contract = purchase(orderLines)&lt;me, vendor&gt;
" /></field><field name="description"><string value="Set up a purchase" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:44.468804Z" /></field><field name="name"><string value="purchase" /></field><field name="recordType"><string value="Purchase" /></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateContractDef"><field name="cslCode"><string value="name: sale
type: Sale
description: &quot;Set up a sale&quot;
// Check if &#39;lines&#39; are in stock by invoking the &#39;Inventory&#39; report
fun inStock lines =
  let inv = (reports.inventory ()).availableItems
  in
  all (\l -&gt; any (\i -&gt; (l.item).itemType == i.itemType &amp;&amp; (l.item).quantity &lt;= i.quantity) inv) lines

// Check that amount &#39;m&#39; equals the total amount in m&#39;s currency of a list of sales lines
fun checkAmount m orderLines =
  let a = foldr (\x acc -&gt;
            if (x.unitPrice).currency == m.currency then
              (x.item).quantity * (100 + x.vatPercentage) * (x.unitPrice).amount + acc
            else
              acc) 0 orderLines
  in
  m.amount * 100 == a

// Remove sales lines that have the currency of &#39;m&#39;
fun remainingOrderLines m = filter (\x -&gt; (x.unitPrice).currency /= m.currency)

// A reference to the designated entity that represents the company
val me = reports.me ()

clause sale(lines : [OrderLine])&lt;me : &lt;Me&gt;, customer : &lt;Customer&gt;&gt; =
 &lt;me&gt; IssueInvoice(sender s, receiver r, orderLines sl)
   where s == me &amp;&amp; r == customer &amp;&amp; sl == lines &amp;&amp; inStock lines
   due within 1H
 then
 payment(lines, me, 10m)&lt;customer&gt;
 and
 &lt;me&gt; Delivery(sender s, receiver r, items i)
   where s == me &amp;&amp; r == customer &amp;&amp; i == map (\x -&gt; x.item) lines
   due within 1W
 then
 repair(map (\x -&gt; x.item) lines, customer, 3M)&lt;me&gt;

clause payment(lines : [OrderLine], me : &lt;Me&gt;, deadline : Duration)&lt;customer : &lt;Customer&gt;&gt; =
 if null lines then
   fulfilment
 else
   &lt;customer&gt; Payment(sender s, receiver r, money m)
     where s == customer &amp;&amp; r == me &amp;&amp; checkAmount m lines
     due within deadline
     remaining newDeadline
   then
   payment(remainingOrderLines m lines, me, newDeadline)&lt;customer&gt;

clause repair(items : [Item], customer : &lt;Customer&gt;, deadline : Duration)&lt;me : &lt;Me&gt;&gt; =
 when RequestRepair(sender s, receiver r, items i)
   where s == customer &amp;&amp; r == me &amp;&amp; subset i items
   due within deadline
   remaining newDeadline
 then
 &lt;me&gt; Repair(sender s, receiver r, items i&#39;)
   where s == me &amp;&amp; r == customer &amp;&amp; i == i&#39;
   due within 5D
   remaining newDeadline&#39;
 then
 repair(items, customer, newDeadline &lt;-&gt; 5D &lt;+&gt; newDeadline&#39;)&lt;me&gt;

contract = sale(orderLines)&lt;me, customer&gt;
" /></field><field name="description"><string value="Set up a sale" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:29:44.506785Z" /></field><field name="name"><string value="sale" /></field><field name="recordType"><string value="Sale" /></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateEntity"><field name="data"><record name="Vendor" /></field><field name="ent"><reference name="Vendor" refId="1" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:43:11.223783Z" /></field><field name="recordType"><string value="Vendor" /></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateContract"><field name="contract"><record name="Purchase"><field name="orderLines"><list><record name="OrderLine"><field name="item"><record name="Item"><field name="itemType"><record name="Product"><field name="description"><string value="" /></field><field name="name"><string value="" /></field><field name="sku"><string value="qwerty" /></field></record></field><field name="quantity"><double value="1000.0" /></field></record></field><field name="unitPrice"><record name="Money"><field name="amount"><double value="100.0" /></field><field name="currency"><record name="DKK" /></field></record></field><field name="vatPercentage"><double value="0.0" /></field></record></list></field><field name="startDate"><datetime value="2011-10-31T14:42:34Z" /></field><field name="templateName"><string value="purchase" /></field><field name="vendor"><reference name="Vendor" refId="1" /></field></record></field><field name="contractId"><int value="0" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:43:13.222264Z" /></field></record>
<record xmlns="http://poets.diku.dk/values" name="TransactionEvent"><field name="contractId"><int value="0" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:43:30.887472Z" /></field><field name="timeStamp"><datetime value="2011-10-31T14:43:29Z" /></field><field name="transaction"><record name="Delivery"><field name="items"><list><record name="Item"><field name="itemType"><record name="Product"><field name="description"><string value="" /></field><field name="name"><string value="" /></field><field name="sku"><string value="qwerty" /></field></record></field><field name="quantity"><double value="1000.0" /></field></record></list></field><field name="receiver"><reference name="Me" refId="0" /></field><field name="sender"><reference name="Vendor" refId="1" /></field></record></field></record>
<record xmlns="http://poets.diku.dk/values" name="TransactionEvent"><field name="contractId"><int value="0" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:44:36.549493Z" /></field><field name="timeStamp"><datetime value="2011-10-31T14:44:35Z" /></field><field name="transaction"><record name="IssueInvoice"><field name="orderLines"><list><record name="OrderLine"><field name="item"><record name="Item"><field name="itemType"><record name="Product"><field name="description"><string value="" /></field><field name="name"><string value="" /></field><field name="sku"><string value="qwerty" /></field></record></field><field name="quantity"><double value="1000.0" /></field></record></field><field name="unitPrice"><record name="Money"><field name="amount"><double value="100.0" /></field><field name="currency"><record name="DKK" /></field></record></field><field name="vatPercentage"><double value="0.0" /></field></record></list></field><field name="receiver"><reference name="Me" refId="0" /></field><field name="sender"><reference name="Vendor" refId="1" /></field></record></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateEntity"><field name="data"><record name="Customer"><field name="addresses"><list><record name="Address"><field name="country"><record name="Denmark" /></field><field name="string"><string value="" /></field></record></list></field><field name="name"><string value="foo" /></field></record></field><field name="ent"><reference name="Customer" refId="2" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:46:03.563859Z" /></field><field name="recordType"><string value="Customer" /></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateContract"><field name="contract"><record name="Sale"><field name="customer"><reference name="Customer" refId="2" /></field><field name="orderLines"><list><record name="OrderLine"><field name="item"><record name="Item"><field name="itemType"><record name="Product"><field name="description"><string value="" /></field><field name="name"><string value="" /></field><field name="sku"><string value="qwerty" /></field></record></field><field name="quantity"><double value="10.0" /></field></record></field><field name="unitPrice"><record name="Money"><field name="amount"><double value="30.0" /></field><field name="currency"><record name="DKK" /></field></record></field><field name="vatPercentage"><double value="0.0" /></field></record></list></field><field name="startDate"><datetime value="2011-10-31T14:45:3Z" /></field><field name="templateName"><string value="sale" /></field></record></field><field name="contractId"><int value="1" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:46:08.137258Z" /></field></record>
<record xmlns="http://poets.diku.dk/values" name="TransactionEvent"><field name="contractId"><int value="1" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:46:22.458895Z" /></field><field name="timeStamp"><datetime value="2011-10-31T14:46:21Z" /></field><field name="transaction"><record name="IssueInvoice"><field name="orderLines"><list><record name="OrderLine"><field name="item"><record name="Item"><field name="itemType"><record name="Product"><field name="description"><string value="" /></field><field name="name"><string value="" /></field><field name="sku"><string value="qwerty" /></field></record></field><field name="quantity"><double value="10.0" /></field></record></field><field name="unitPrice"><record name="Money"><field name="amount"><double value="30.0" /></field><field name="currency"><record name="DKK" /></field></record></field><field name="vatPercentage"><double value="0.0" /></field></record></list></field><field name="receiver"><reference name="Customer" refId="2" /></field><field name="sender"><reference name="Me" refId="0" /></field></record></field></record>
<record xmlns="http://poets.diku.dk/values" name="TransactionEvent"><field name="contractId"><int value="1" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T13:47:01.00126Z" /></field><field name="timeStamp"><datetime value="2011-10-31T14:46:59Z" /></field><field name="transaction"><record name="Delivery"><field name="items"><list><record name="Item"><field name="itemType"><record name="Product"><field name="description"><string value="" /></field><field name="name"><string value="" /></field><field name="sku"><string value="qwerty" /></field></record></field><field name="quantity"><double value="10.0" /></field></record></list></field><field name="receiver"><reference name="Customer" refId="2" /></field><field name="sender"><reference name="Me" refId="0" /></field></record></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateEntity"><field name="data"><record name="Customer"><field name="addresses"><list><record name="Address"><field name="country"><record name="Denmark" /></field><field name="string"><string value="" /></field></record></list></field><field name="name"><string value="foo" /></field></record></field><field name="ent"><reference name="Customer" refId="3" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T14:35:04.699748Z" /></field><field name="recordType"><string value="Customer" /></field></record>
<record xmlns="http://poets.diku.dk/values" name="CreateContract"><field name="contract"><record name="Sale"><field name="customer"><reference name="Customer" refId="3" /></field><field name="orderLines"><list><record name="OrderLine"><field name="item"><record name="Item"><field name="itemType"><record name="Product"><field name="description"><string value="" /></field><field name="name"><string value="" /></field><field name="sku"><string value="aghast" /></field></record></field><field name="quantity"><double value="15.0" /></field></record></field><field name="unitPrice"><record name="Money"><field name="amount"><double value="100.0" /></field><field name="currency"><record name="DKK" /></field></record></field><field name="vatPercentage"><double value="0.0" /></field></record></list></field><field name="startDate"><datetime value="2011-10-31T15:34:32Z" /></field><field name="templateName"><string value="sale" /></field></record></field><field name="contractId"><int value="2" /></field><field name="internalTimeStamp"><datetime value="2011-10-31T14:35:56.097141Z" /></field></record>
